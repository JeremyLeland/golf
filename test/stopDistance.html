<title>Validating stopping distance</title>
<link rel="stylesheet" href="../style.css">

<script type="module">
  import { Canvas } from '../src/Canvas.js';
  import { World } from '../src/World.js';
  import * as Level from '../src/Level.js';
  import { Line } from '../src/Line.js';

  const lines = [];

  const NUM_LINES = 8, LINE_LEN = 2;
  for ( let i = 0; i < NUM_LINES; i++ ) {
    const angle = ( i / NUM_LINES ) * ( Math.PI / 3 );
    const x = 2.2 * Math.floor( 2 * i / NUM_LINES );
    const y = i % ( NUM_LINES / 2 );
    lines.push(
      new Line( x, y, x + LINE_LEN * Math.cos( angle ), y + LINE_LEN * Math.sin( angle ) ),
    );
  }

  const PLAYER_RADIUS = 0.1;
  const GRAVITY = 0.00001;
  const ROLL_FRICTION = 5.0;


  const SIZE = 5;
  const canvas = new Canvas();
  canvas.zoom = 1 / SIZE;
  canvas.scrollX = SIZE / 8;
  canvas.scrollY = SIZE / 8;

  canvas.draw = ( ctx ) => {
    // TODO: Need to iron out stop distance to make sure it makes sense

    // Have a bunch of different slopes and show the stop time for them
    // Independent from everything else in World for the moment

    const START_SPEED = 0.01;

    ctx.lineWidth = 0.1 * canvas.zoom;
    lines.forEach( line => {
      ctx.strokeStyle = 'green';
      line.draw( ctx );

      const normAngle = line.normalAngle;
      const startX = line.x1 + Math.cos( normAngle ) * PLAYER_RADIUS;
      const startY = line.y1 + Math.sin( normAngle ) * PLAYER_RADIUS;

      const slopeAngle = line.slopeAngle;

      const lineSlopeX = Math.cos( slopeAngle );
      const lineSlopeY = Math.sin( slopeAngle );

      const playerSlopeX = lineSlopeX;  // TODO: Account for direction of travel
      const playerSlopeY = lineSlopeY;  // TODO: Account for direction of travel

      const playerSpeed = START_SPEED;

      const a = GRAVITY * ( playerSlopeY - ROLL_FRICTION * playerSlopeX );    // TODO: base friction on line slope or player slope?

      const player = {
        x: startX,
        y: startY,
        dx: playerSpeed * playerSlopeX,
        dy: playerSpeed * playerSlopeY,
        ax: a * playerSlopeX,
        ay: a * playerSlopeY,
      };

      const stopPlayer = Object.assign( {}, player );

      const COLORS = [ 'red', 'orange', 'yellow', 'green', 'dodgerblue' ];

      for ( let i = 0; i < 30; i ++ ) {
        ctx.fillStyle = COLORS[ i % COLORS.length ];
        drawPlayer( ctx, player );

        const nextTime = 10;

        player.x += player.dx * nextTime + 0.5 * player.ax * nextTime * nextTime;
        player.y += player.dy * nextTime + 0.5 * player.ay * nextTime * nextTime;
        
        player.dx += player.ax * nextTime;
        player.dy += player.ay * nextTime;
      }

      const brakeTime = playerSpeed / ( GRAVITY * ( playerSlopeY + ROLL_FRICTION * playerSlopeX ) );

      stopPlayer.x += stopPlayer.dx * brakeTime + 0.5 * stopPlayer.ax * brakeTime * brakeTime;
      stopPlayer.y += stopPlayer.dy * brakeTime + 0.5 * stopPlayer.ay * brakeTime * brakeTime;
      
      stopPlayer.dx += stopPlayer.ax * brakeTime;
      stopPlayer.dy += stopPlayer.ay * brakeTime;

      ctx.strokeStyle = 'white';
      drawPlayer( ctx, stopPlayer, false );
      
      ctx.fillStyle = 'white';
      const fontSize = 0.08;
      ctx.font = `${ fontSize }px Arial`;
      JSON.stringify( stopPlayer ).replace( /[\{\}]/gi,'').split( ',' ).forEach( ( str, index ) => {
        ctx.fillText( str, stopPlayer.x + 2 * fontSize, stopPlayer.y + fontSize * index );
      } );

    } );
  }

  canvas.redraw();

  function drawPlayer( ctx, player, fill = true ) {
    ctx.beginPath();
    ctx.arc( player.x, player.y, PLAYER_RADIUS, 0, Math.PI * 2 );
    ctx.closePath();

    if ( fill ) {
      ctx.fill();
    }
    else {
      ctx.stroke();
    }
  }

</script>