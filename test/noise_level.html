<link rel='stylesheet' href='../style.css'>

<body>
  <canvas id='canvas' width="10000" height="500"></canvas>
</body>

<script type='module'>
  import { Curve } from '../src/Curve.js';
  import { Wall } from '../src/Wall.js';
  import * as Noise from '../lib/noise/2d.js';

  class Flag {
    x;
    y;

    static #pole = new Path2D( 'M 0 0 V -1 H 0.1 V 0' );
    static #flag = new Path2D( 'M 0 -1 L 1 -0.75 L 0 -0.5' );

    constructor( x, y ) {
      this.x = x;
      this.y = y;
    }

    draw( ctx ) {
      ctx.save();

      ctx.translate( this.x, this.y );
      ctx.scale( 10, 20 );

      ctx.fillStyle = 'white';
      ctx.fill( Flag.#pole );
      ctx.fillStyle = 'red';
      ctx.fill( Flag.#flag );

      ctx.restore();
    }
  }

  const noise = Noise.makeNoise2D();

  const LEVEL_HEIGHT = 500;

  const points = { top: [], mid: [], bottom: [] };

  for ( let i = 0; i < 20; i ++ ) {
    const x = i * 400;
    const mid = LEVEL_HEIGHT / 2 + noise( x * 0.01, i ) * LEVEL_HEIGHT / 3;

    points.mid.push( { x: x, y: mid } );

    const radius = Math.min( mid, LEVEL_HEIGHT - mid ) * ( 1 + noise( x * 0.01, 1 ) ) / 2;

    const top    = mid - radius;
    const bottom = mid + radius;

    points.top.unshift( { x: x, y: top } );
    points.bottom.push( { x: x, y: bottom } );
  }

  const topCurves = Curve.getCurvesThroughPoints( points.top );
  const midCurves = Curve.getCurvesThroughPoints( points.mid );
  const bottomCurves = Curve.getCurvesThroughPoints( points.bottom );

  const canvas = document.getElementById( 'canvas' );
  const ctx = canvas.getContext( '2d' );

  // topCurves.forEach( curve => curve.draw( ctx ) );
  midCurves.forEach( curve => curve.draw( ctx ) );
  // bottomCurves.forEach( curve => curve.draw( ctx ) );

  // Draw altered points, or just make walls from them
  const topWalls = getWallsFromPoints( getAlteredPoints( topCurves ) );
  const bottomWalls = getWallsFromPoints( getAlteredPoints( bottomCurves ) );

  const walls = topWalls.concat( bottomWalls );

  walls.forEach( wall => wall.draw( ctx ) );

  // Find flattest points for flags
  const flags = [];

  for ( let i = 1; i < bottomWalls.length - 1; i ++ ) {
    const prev = bottomWalls[ i - 1 ];
    const current = bottomWalls[ i ];
    const next = bottomWalls[ i + 1 ];

    if ( current.normal.y < -0.99 && 
         current.normal.y < prev.normal.y && current.normal.y < next.normal.y ) {
      flags.push( new Flag( current.x1, current.y1 ) );
    }
  }

  flags.forEach( flag => flag.draw( ctx ) );

  ctx.beginPath();
  ctx.moveTo(     0, LEVEL_HEIGHT );
  ctx.lineTo( 10000, LEVEL_HEIGHT );
  ctx.stroke();

  function getAlteredPoints( curves ) {
    const points = [];

    curves.forEach( curve => {
      for ( let t = 0; t <= 1; t += 0.05 ) {
        const pos = curve.getPosition( t );
        const norm = curve.getNormal( t );

        const offset = 10 * Math.sin( t * Math.PI * 2 * 4321 );

        points.push( { 
          x: pos.x + norm.x * offset,
          y: pos.y + norm.y * offset,
        } );
      }
    } );

    return points;
  }

  // TODO: Loop, reverse?
  function getWallsFromPoints( points ) {
    const walls = [];

    for ( let i = 0; i < points.length - 1; i ++ ) {
      const current = points[ i ], next = points[ i + 1 ];
      walls.push( new Wall( current.x, current.y, next.x, next.y ) );
    }

    return walls;
  }

  function octaveNoise( x, y, octaves = 10 ) {
    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;

    for ( let i = 0; i < octaves; i++ ) {
      total += noise( x * frequency, y * frequency ) * amplitude;

      maxValue += amplitude;
      amplitude *= 0.5;
      frequency *= 2.0;
    }

    return total / maxValue;
  }
  
</script>
