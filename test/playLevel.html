<title>Play Single Level</title>
<link rel="stylesheet" href="../style.css">

<style>
  #ui {
    position: absolute;
    display: grid;
    grid-template-columns: 150px 75px;
    text-align: center;
    opacity: 0.5;
  }
</style>

<div id="ui"></div>

<script type="module">
  import { Canvas } from '../src/Canvas.js';
  import { World } from '../src/World.js';
  import * as Level from '../src/Level.js';
  import { Line } from '../src/Line.js';


  makeUIFrom( World.Constants );

  function makeUIFrom( vals ) {
    const uiDiv = document.getElementById( 'ui' );

    for ( const val in vals ) {
      const ui = document.createElement( 'input' );
      ui.type = 'number';
      ui.step = 0.01;
      
      ui.value = vals[ val ];
      ui.addEventListener( 'input', e => {
        vals[ val ] = +e.target.value;
        canvas.redraw();
      } );

      uiDiv.appendChild( document.createTextNode( val ) );
      uiDiv.appendChild( ui );
    }
  }


  let world = new World( await ( await fetch( '../levels/test3.json' ) ).json() )

  const SIZE = 16;
  const canvas = new Canvas();
  canvas.zoom = 1 / SIZE;
  canvas.scrollX = SIZE / 2;
  canvas.scrollY = SIZE / 2;
  
  let dragStart;

  const pullGrad = canvas.ctx.createRadialGradient( 0, 0, 0, 0, 0, 2 );
  pullGrad.addColorStop( 0, 'green' );
  pullGrad.addColorStop( 0.5, 'yellow' );
  pullGrad.addColorStop( 1, 'red' );

  canvas.update = ( dt ) => {
    world.update( dt );
  }

  canvas.draw = ( ctx ) => {
    world.draw( ctx );

    if ( dragStart ) {
      const cx = dragStart.x - mouse.x;
      const cy = dragStart.y - mouse.y;
      const angle = Math.atan2( cy, cx );
      const dist = Math.hypot( cx, cy );

      const offX =  Math.sin( angle ) * world.player.radius;
      const offY = -Math.cos( angle ) * world.player.radius;

      ctx.translate( world.player.x, world.player.y );
      ctx.beginPath();
      ctx.lineTo( offX, offY );
      ctx.lineTo( -offX, -offY );
      ctx.lineTo( -Math.cos( angle ) * dist, -Math.sin( angle ) * dist );

      ctx.fillStyle = pullGrad;
      ctx.fill();
      ctx.translate( -world.player.x, -world.player.y );
    }

    ctx.fillStyle = 'white';
    ctx.font = '1px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText( world.strokes, 0, -SIZE / 2 );
    
    if ( world.victory ) {
      ctx.font = '2px Arial';
      ctx.textBaseline = 'middle';
      ctx.fillText( 'Victory!', 0, 0 );
    }
  }

  canvas.start();
  
  let mouse = {
    x: 0,
    y: 0,
  };

  function updateMousePos( e ) {
    mouse.x = canvas.getPointerX( e );
    mouse.y = canvas.getPointerY( e );
  }

  
  canvas.canvas.addEventListener( 'pointerdown', e => {
    if ( world.readyForInput ) {
      updateMousePos( e );
      
      dragStart ??= {
        x: mouse.x,
        y: mouse.y
      };
    }
  } );

  canvas.canvas.addEventListener( 'pointermove', e => {
    updateMousePos( e );
  } );

  canvas.canvas.addEventListener( 'pointerup', e => {
    if ( dragStart ) {
      const SENSITIVITY = 0.01;
      
      const cx = dragStart.x - mouse.x;
      const cy = dragStart.y - mouse.y;
      const angle = Math.atan2( cy, cx );
      const dist = Math.hypot( cx, cy );
      
      world.hitBall(
        SENSITIVITY * dist * Math.cos( angle ),
        SENSITIVITY * dist * Math.sin( angle )
      );
      
      dragStart = null;
    }
  } );

</script>